1. An alternative to polling is to instrument the pods with a sidecar that pushes metrics to prometheus directly. A benfit of this is fewer API calls to the k8s API server and having the pods report their state directly to prometheus. The metric in prometheus would also need to be changed to be a collector to report metrics correctly. I don't see this as much of a benefit, though. It increases the compelxity of the system and makes the pods fatter.

2. To generalize this monitor, I would refactor the code to be more modular by writing functions for the desired resources and switching on those functions to dispatch the correct function based on resource type. Thinking about types and interfaces that would generalize the application and improve type safety is also a useful exercise.

3. To test the code, I would modularize the implementation. This can be accomplished by creating a package and breaking components out into individual functions to be imported into main.go. Each group of core and helper functions could be in one monolithic go file or broken out into individual files of core functions with their helper functions. I prefer the latter as it makes the code more readbale and comprehensible. Once the core and helper fucntions are refactored, creating <function>_test.go files for the test code is necessary to leverage the full capabilities of the go tooling. Related to testing would be becnhmarks to ensure performance regressions are not introduced as the code evolves.

4. This is a quick and dirty implementation and has room for optimization. At the very least it can be made more readbale by refactoring functionality into individual functions and thinking about types and interfaces that might be useful for making the code more clean and type safe. Another area to consider for optimization is better use of channels and go routines to parallelize polling.